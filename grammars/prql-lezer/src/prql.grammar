// TODO:
// - Do we want to highlight built-in transforms such as `from` differently to
//   normal functions?
// - A few small TODOs included below

@top Query { Statements }
@skip { space | Comment | wrapped_line }

Statements { newline* Query_def? (Def)* Pipeline_stmt? end }

Query_def { @specialize<ident_part, "prql"> Named_arg* newline+ }

Pipeline_stmt { Pipeline ( ~ambig_newline newline+ | end )}

Pipeline { expr_call (pipe+ expr_call)* }

pipe { "|" | ~ambig_newline newline }

Tuple { "{" newline* tuple_item (("," newline* ) tuple_item)* ","? newline* "}" }

tuple_item { Assign_call | expr_call | Case_branch }

expr_call { Expr | Func_call }
// Ideally we would force a space after `Ident` to prevent an invalid s-string
// being parsed as a Func_call, e.g. `s"{a"` -> `s` & `"{a"'. But we
// can't seem to force a space because it's in our skip, and I can't see
// a way of changing the skip expression to only specialize on a single item
Func_call { Ident ( (Named_arg | Assign | Expr))+ }

// !term is required here, otherwise `[x+emp_no, -3]` is parsed as `x` & `+emp_no`
term { !term Ident | number | Tuple | DateTime | Nested_pipeline | op_unary term | String | R_string | S_string | F_string | Range | Array | Case }

Expr { term (( Op_bin ) term )* }

Named_arg { ident_part ":" Expr }
Assign { ident_part "=" Expr }
Assign_call { ident_part "=" expr_call }
Case_branch { Expr "=>" Expr }
Array { "[" newline* Expr (("," newline* ) Expr)* ","? newline* "]" }
// Possibly we could only accept case branches inside the Tuple?
Case { @specialize<ident_part, "case"> Tuple }

Nested_pipeline { "(" newline* Pipeline ~ambig_newline newline? ")" }

@precedence { term @left }

// Because this is outside tokens, we can't disallow whitespace.
// It's outside tokens because otherwise it conflicts with Ident
Ident { ident_part ( "." (ident_part | "*"))* }

// I don't think it's possible to have `Op_bin` & `Op_unary` as tokens â€” that
// would mean `-` can't be both unary & bin.
Op_bin { op_bin_only | !term op_unary }

number { Integer time_unit? | Float }

@tokens {
  date { @digit+ "-" @digit+ "-" @digit+ }
  time { @digit+ ":" @digit+ ( ":" @digit+ ( "." @digit+ )? )? }
  // We can't seem to set the number of digits, so this will allow any
  // combination of digits & hyphens.
  DateTime { "@" ( date | time | date "T" time ( "Z" | ( "-" | "+" ) @digit+ ":" @digit+ )? ) }
  time_unit { "years" | "months" | "weeks" | "days" | "hours" | "minutes" | "seconds" | "milliseconds" | "microseconds" }
  identifier_char { @asciiLetter | $[_\u{a1}-\u{10ffff}] }
  ident_part { identifier_char (identifier_char | "_" | @digit )* }
  Integer { @digit ( @digit | "_" )* ("e" Integer)? }
  Float { @digit ( @digit | "_" )* "." @digit ( @digit | "_" )* ("e" Integer)? }
  // TODO: This is not as precise as PRQL, which doesn't allow trailing
  // underscores and allows no digit before the decimal point.
  space { " "+ }
  Comment { "#" ![\n]* }
  op_bin_only { "*" | "/" | "//" | "%" | "!=" | ">=" | "<=" | "~=" | ">" | "<" | "??" | "&&" | "||" }
  op_unary { "-" | "+" | "==" }
  end { @eof }
  line_wrap { "\\" }
  wrapped_line { newline+ (Comment newline+)* line_wrap }
  newline { "\n" }
  // TODO: Because this can also be used to compile to BETWEEN, ranges should
  // allow any literal, and arguably any expression.
  Range { @digit+ ".." @digit+ }
  // Couldn't manage to do these & the interpolated as a template; couldn't
  // find how to negate a variable template
  String { $["] !["]* $["] | $['] ![']* $['] }

  // TODO: not getting the interpolations highlighted; it just shows the whole
  // string as a string, because these are all within the `@tokens` block. But
  // they need to be within this block, because it's not possible to have
  // negations (e.g. `![{'}` outside it.
  String_interpolated_single { $['] ( ![{'] | Interpolation_inner_single )* $['] }
  String_interpolated_double { $["] ( ![{"] | Interpolation_inner_double )* $["] }

  Interpolation_inner_single { "{" ![}']* "}" }
  Interpolation_inner_double { "{" ![}"]* "}" }

  Interpolated_string<prefix> { prefix ( String_interpolated_double | String_interpolated_single ) }

  R_string {Interpolated_string<'r'>}
  S_string {Interpolated_string<'s'>}
  F_string {Interpolated_string<'f'>}

  // We need to give precedence to `Op_bin` so we don't get `x+y` as `x` & `+y`.
  // R, S & F strings have precedence over idents beginning with r / s / f (we could
  // use specialize but I think means we need to redefine `String` for each)
  @precedence { R_string, S_string, F_string, op_bin_only, ident_part }

  @precedence { Range, Float, Integer, time_unit, ident_part }
}

Def { @specialize<ident_part, "let"> ident_part "=" (Nested_pipeline (newline+ | end) | Lambda) }

Lambda { Lambda_param* "->" expr_call ( newline+ | end ) }
Type_def { "<" Type_term ( "|" Type_term)* ">" }
Type_term { ident_part Type_def? }
Lambda_param { ident_part Type_def? (":" Expr)? }

@external propSource prqlHighlight from "./highlight"
