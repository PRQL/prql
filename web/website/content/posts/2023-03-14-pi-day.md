# Calculating the digits of Pi in DuckDB with PRQL

## Background

Last week saw the 0.6 release of [PRQL](www.prql-lang.org) which brought with it
the capability to express Recursive CTEs in PRQL. "Recursive" CTEs aren't
actually truly recursive in the sense that that term is usually used, rather
they use a "recursive" (i.e. self-referential) syntax to provide a looping
construct in SQL.

[PRQL](www.prql-lang.org) is a modern, functional query language for
transforming data. One of its goals is to simplify working with data wherever
you can currently use SQL. As such it compiles to SQL while making available
modern ergonomics such as
[f-strings](https://prql-lang.org/book/language-features/f-strings.html), as
well as not so modern features such as
[functions](https://prql-lang.org/book/queries/functions.html).

Given that the underlying semantics of Recursive CTEs are really about iteration
or "looping", we have called this feature `loop` in PRQL.

## Introducing `loop`

Recursive CTEs in SQL consist of two parts, an `initial_query` and an
`update_query`. First the `initial_query` is executed and then the rows produced
are fed to `update_query` which is applied to the result set. The `update_query`
is then iteratively applied to the rows produced in the last iteration until no
more rows are produced, at which point iteration stops. (For a great review of
this as well as some interesting proposals to extend the semantics of Recursive
CTEs in SQL, see the paper
["A Fix for the Fixation on Fixpoints" by Denis Hirn and Torsten Grust](https://www.cidrdb.org/cidr2023/papers/p14-hirn.pdf).)

This behavior can be expressed with following pseudo-code:

```python
def loop(step, initial_query):
    result = []
    current = initial_query()
    while current is not empty:
        result = append(result, current)
        current = update_query(current)

    return result
```

The minimal `loop` example from the documentation in the
[PRQL book](https://prql-lang.org/book/language-features/standard-library/loop.html)
is:

```elm=
from_text format:json '[{"n": 1 }]'
loop (
    select n = n+1
    filter n<=3
)
```

Here we use a PRQL utility function `from_text` to conveniently turn a JSON
representation of some example data into a SQL table (`from_text` currently also
accepts CSV input).

Initially a row with `{"n":1}` is fed in. Then the update query is applied to
this which in this case just increments `n` by one and filters the result set to
only the rows where `n` is less than or equal to three. This produces `{"n":2}`
in the next step and `{"n":3}` after that. On the next iteration `{"n":4}` is
produced but that is eliminated by the filter condition. Since that leaves no
new rows, iteration stops.

If you try the query above in the
[PRQL Playground](www.prql-lang.org/playground), the result set you get (in the
"output.arrow" tab) is:

| n   |
| --- |
| 1   |
| 2   |
| 3   |

## Fibonacci Numbers

Inspired by this, let's try to calculate Fibonnacci numbers which are often one
of the first examples when recursion is introduced:

```elm=
from_text format:json '[{"a":1, "b":1}]'
loop (
    select [a=b, b=s"a"+b]
)
select a
take 7
```

which produces the first 7 Fibonnaci numbers.

| a   |
| --- |
| 1   |
| 1   |
| 2   |
| 3   |

|5 |8| |13|

You might have noticed that we didn't actually include a `filter` in our loop
this time. Instead we relied on the fact that DuckDB produces results lazily and
since we only took 7 numbers it only produced what we needed.

Now, let's set ourselves a bigger challenge.

## Calculating the digits of pi

March 14th is written on American calendars as 3/14 which reminds us of the
first three digits of Pi=3.1415926535... . Therefore this day is commonly known
as Pi day. In order to celebrate Pi Day 2023 and the recent release of `loop` in
PRQL 0.6, why don't we try to calculate the digits of Pi in PRQL!

For our query engine we will use [DuckDB](https://duckdb.org/) because it is
really fast and has many modern features that make it ideally suited for the
kinds of analytical queries that PRQL is targeting. There is even a
[duckdb-prql](https://github.com/ywelsch/duckdb-prql) extension which allows you
to write PRQL queries right inside DuckDB!

We follow the algorithms in the paper
["Unbounded Spigot Algorithms for the Digits of Pi" by Jeremy Gibbons](https://www.cs.ox.ac.uk/people/jeremy.gibbons/publications/spigot.pdf),
in particular Rabinowitz and Wagon's Spigot Algorithm. While it is not the most
efficient algorithm presented in the paper, it has the advantage that it uses
only standard data types while the more efficient algorithms rely on unbounded
integer types which are not available in many database systems.

For my implementation, I adapted the Python implementation by John Burkardt
found
[here](https://people.sc.fsu.edu/~jburkardt/py_src/pi_spigot/pi_spigot.py). A
bit of care had to be taken in porting the implementation to PRQL, as PRQL like
SQL, is stateless so I introduced another state variable `k` to track the
position inside the body of the loop.

The resulting PRQL query is the following:

```prql
prql target:sql.duckdb

let config = (
    from_text format:json '[{"n":50}]'
    derive [
        len = (10*n)/3,
        calc_len = 1+4,
        loop_len = len + calc_len,
        ]
)

func loop_steps step_0 step_i step_1 step_2 step_3 other -> case [
    s"k"==0 => step_0,
    1 <= s"k" and s"k" <= s"len" => step_i,
    s"k"==s"len"+1 => step_1,
    s"k"==s"len"+2 => step_2,
    s"k"==s"len"+3 => step_3,
    true => other,
]

func q_steps step_q9 step_q10 step_j2 step_jg2 other -> case [
    s"q"==9 => step_q9,
    s"q"==10 => step_q10,
    s"j"==2 => step_j2,
    s"j">2 => step_jg2,
    true => other,
]


from config
select [
    n,
    len,
    loop_len,
    j = 0, 
    k = 0,
    q = 0,
    a = s"[2 for i in range(len)]",
    nines = 0,
    predigit = 0,
    output = '',
]
loop (
    filter j < n + 1
    select [
        n,
        len,
        loop_len,
        j = case [k==0 => j+1, true => j],
        k = (k+1) % loop_len,
        q = loop_steps 0 ((10*s"a[k]" + q*(len-s"k"+1)) / (2*(len-s"k") + 1)) (q/10) q q q,
        a = loop_steps a s"[CASE WHEN i==k THEN (10*a[i] + q*(len-i+1)) % (2*(len-i) + 1) ELSE a[i] END for i in generate_series(1, len)]" s"[CASE WHEN i==len THEN q % 10  ELSE a[i] END for i in generate_series(1, len)]" a a a,
        nines = loop_steps nines nines nines (q_steps (nines+1) 0 nines nines nines) (case [s"q"!=9 and s"q"!=10 and s"nines"!=0 => 0, true => nines]) nines,
        predigit = loop_steps s"predigit" s"predigit" s"predigit" (q_steps s"predigit" 0 s"q" s"q" s"q") s"predigit" s"predigit",
        output = loop_steps '' '' '' (q_steps '' s"(predigit+1)::string || repeat('0',nines)" s"predigit::string || '.'" s"predigit::string" '') (case [s"q"!=9 and s"q"!=10 and s"nines"!=0 => s"repeat('9', nines)", true => '']) '',
    ]
)
select [pi=s"string_agg(output, '')"]
```

Which produces the output:

```
┌────────────────────────────────────────────────────┐
│                         pi                         │
│                      varchar                       │
├────────────────────────────────────────────────────┤
│ 3.141592653589793238462643383279502884197169399375 │
└────────────────────────────────────────────────────┘
```

I actually cheated a little bit as the SQL produced by the PRQL query above
didn't work immediately in DuckDB. The `loop` functionality in PRQL is brand new
and is marked as _experimental_ so expect there to be some changes as we iterate
on how to make it as easy and useful as possible.

The following query is a slightly edited version of the SQL query produced by
the PRQL query above (the only edits where that expressions of the form
`_expr_{x}` were replaced by the equivalent column names):

```sql
WITH table_0 AS (
  SELECT
    50 AS n
),
config AS (
  SELECT
    n,
    10 * n / 3 AS len,
    5 AS calc_len,
    10 * n / 3 + 5 AS loop_len
  FROM
    table_0 AS table_1
),
table_4 AS (
  WITH RECURSIVE loop AS (
    SELECT
      n,
      len,
      loop_len,
      0 AS j,
      0 AS k,
      0 AS q,
      [2 for i in range(len)] AS a,
      0 AS nines,
      0 AS predigit,
      '' AS output
    FROM
      config
    UNION
    ALL
    SELECT
      n,
      len,
      loop_len,
      CASE
        WHEN k = 0 THEN j + 1
        ELSE j
      END,
      (k + 1) % loop_len,
      CASE
        WHEN k = 0 THEN 0
        WHEN 1 <= k
        AND k <= len THEN (10 * a [k] + q * (len - k + 1)) / (2 * (len - k) + 1)
        WHEN k = len + 1 THEN q / 10
        WHEN k = len + 2 THEN q
        WHEN k = len + 3 THEN q
        ELSE q
      END,
      CASE
        WHEN k = 0 THEN a
        WHEN 1 <= k
        AND k <= len THEN [CASE WHEN i==k THEN (10*a[i] + q *(len - i + 1)
      ) % (2 *(len - i) + 1)
      ELSE a [i]
  END for i in generate_series(1, len) ]
  WHEN k = len + 1 THEN [CASE WHEN i==len THEN q % 10  ELSE a[i]
END for i in generate_series(1, len) ]
WHEN k = len + 2 THEN a
WHEN k = len + 3 THEN a
ELSE a
END,
CASE
  WHEN k = 0 THEN nines
  WHEN 1 <= k
  AND k <= len THEN nines
  WHEN k = len + 1 THEN nines
  WHEN k = len + 2 THEN CASE
    WHEN q = 9 THEN nines + 1
    WHEN q = 10 THEN 0
    WHEN j = 2 THEN nines
    WHEN j > 2 THEN nines
    ELSE nines
  END
  WHEN k = len + 3 THEN CASE
    WHEN q <> 9
    AND q <> 10
    AND nines <> 0 THEN 0
    ELSE nines
  END
  ELSE nines
END,
CASE
  WHEN k = 0 THEN predigit
  WHEN 1 <= k
  AND k <= len THEN predigit
  WHEN k = len + 1 THEN predigit
  WHEN k = len + 2 THEN CASE
    WHEN q = 9 THEN predigit
    WHEN q = 10 THEN 0
    WHEN j = 2 THEN q
    WHEN j > 2 THEN q
    ELSE q
  END
  WHEN k = len + 3 THEN predigit
  ELSE predigit
END,
CASE
  WHEN k = 0 THEN ''
  WHEN 1 <= k
  AND k <= len THEN ''
  WHEN k = len + 1 THEN ''
  WHEN k = len + 2 THEN CASE
    WHEN q = 9 THEN ''
    WHEN q = 10 THEN (predigit + 1) :: string || repeat('0', nines)
    WHEN j = 2 THEN predigit :: string || '.'
    WHEN j > 2 THEN predigit :: string
    ELSE ''
  END
  WHEN k = len + 3 THEN CASE
    WHEN q <> 9
    AND q <> 10
    AND nines <> 0 THEN repeat('9', nines)
    ELSE ''
  END
  ELSE ''
END
FROM
  loop AS table_2
WHERE
  j < n + 1
)
SELECT
  *
FROM
  loop
)
SELECT
  string_agg(output, '') AS pi
FROM
  table_4 AS table_3

-- Generated by PRQL compiler version:0.6.0 (https://prql-lang.org)
```

## Conclusion

Recursive CTEs in SQL make SQL Turing Complete and the same should hold for PRQL
now that `loop` is included. As we saw above, not all algorithms are easily
expressed in this paradigm, so while theoretically they could be, whether they
should be is another question. However I hope this example demonstrates that
`loop` brings great power to PRQL and in follow posts I will demonstrate how we
can use this to do tree and graph traversals which do come up in practice in the
kind of analytical data work that PRQL is made for. After that I will also look
at online algorithms such as moving averages an online gradient descent so be
sure to come back for those!
