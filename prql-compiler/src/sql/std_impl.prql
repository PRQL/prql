let min = <scalar || column> column ->  s"MIN({column})"
let max = <scalar || column> column ->  s"MAX({column})"
let sum = <scalar || column> column ->  s"SUM({column})"
let avg = <scalar || column> column ->  s"AVG({column})"
let stddev = <scalar || column> column ->  s"STDDEV({column})"
let average = <scalar || column> column ->  s"AVG({column})"
let count = <scalar || column> non_null:s"*" ->  s"COUNT({non_null})"
# TODO: Possibly make this into `count distinct:true` (or like `distinct:` as an
# abbreviation of that?)
let count_distinct = <scalar || column> column ->  s"COUNT(DISTINCT {column})"

# Window functions
func lag<column> offset column ->  s"LAG({column}, {offset})"
func lead<column> offset column ->  s"LEAD({column}, {offset})"
func first<column> offset column ->  s"FIRST_VALUE({column}, {offset})"
func last<column> offset column ->  s"LAST_VALUE({column}, {offset})"
func rank<column> ->  s"RANK()"
func rank_dense<column> ->  s"DENSE_RANK()"
func row_number<column> ->  s"ROW_NUMBER()"

# Other functions
func round<scalar> n_digits column ->  s"ROUND({column}, {n_digits})"
func as<scalar> `noresolve.type` column ->  s"CAST({column} AS {type})"

# String functions
let lower = <text> column -> s"LOWER({column})"
let upper = <text> column -> s"UPPER({column})"

# Source-reading functions, primarily for DuckDB
func read_parquet<table> source<text> -> s"SELECT * FROM read_parquet({source})"
func read_csv<table> source<text> -> s"SELECT * FROM read_csv_auto({source})"

let mul = l r -> null
let div = l r -> null
let mod = l r -> null
let add = l r -> null
let sub = l r -> null
let eq = l r -> null
let ne = l r -> null
let gt = l r -> null
let lt = l r -> null
let gte = l r -> null
let lte = l r -> null
let and = l r -> null
let or = l r -> null
let coalesce = l r -> s"COALESCE({l}, {r})"
let neg = l -> null
let not = l -> null
