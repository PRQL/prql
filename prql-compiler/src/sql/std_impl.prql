let min = column -> <scalar || column> s"MIN({column})"
let max = column -> <scalar || column> s"MAX({column})"
let sum = column -> <scalar || column> s"SUM({column})"
let avg = column -> <scalar || column> s"AVG({column})"
let stddev = column -> <scalar || column> s"STDDEV({column})"
let average = column -> <scalar || column> s"AVG({column})"
let count = non_null:s"*" -> <scalar || column> s"COUNT({non_null})"
# TODO: Possibly make this into `count distinct:true` (or like `distinct:` as an
# abbreviation of that?)
let count_distinct = column -> <scalar || column> s"COUNT(DISTINCT {column})"

# Window functions
let lag = offset column -> <column> s"LAG({column}, {offset})"
let lead = offset column -> <column> s"LEAD({column}, {offset})"
let first = offset column -> <column> s"FIRST_VALUE({column}, {offset})"
let last = offset column -> <column> s"LAST_VALUE({column}, {offset})"
let rank = -> <column> s"RANK()"
let rank_dense = -> <column> s"DENSE_RANK()"
let row_number = -> <column> s"ROW_NUMBER()"

# Other functions
let round = n_digits column -> <scalar> s"ROUND({column}, {n_digits})"
let as = `noresolve.type` column -> <scalar> s"CAST({column} AS {type})"

# String functions
let lower = column -> <text> s"LOWER({column})"
let upper = column -> <text> s"UPPER({column})"

# Source-reading functions, primarily for DuckDB
let read_parquet = source<text> -> <table> s"SELECT * FROM read_parquet({source})"
let read_csv = source<text> -> <table> s"SELECT * FROM read_csv_auto({source})"

let mul = l r -> null
let div = l r -> null
let mod = l r -> null
let add = l r -> null
let sub = l r -> null
let eq = l r -> null
let ne = l r -> null
let gt = l r -> null
let lt = l r -> null
let gte = l r -> null
let lte = l r -> null
let and = l r -> null
let or = l r -> null
let coalesce = l r -> s"COALESCE({l}, {r})"
let neg = l -> null
let not = l -> null
