# The PRQL standard library defines the following functions and transforms.
# The definitions are whitespace insensitive, and have this form:
#
# let my_func = <return_type> param1 param2 ...  -> body_expr
# where:
#   * my_func is the name of the function
#   * <return_type> is the type of result wrapped in "< ... >"
#   * param1 is the first parameter optionally followed by a type in "< ... >"
#   * param2 etc. follow the same pattern as param1
#   * -> body_expr defines the function body that creates the result.
#     It can be PRQL code or "null" to indicate internal compiler code

## Types

# Type primitives
type int
type float
type bool
type text
type date
type time
type timestamp

# Relation (an array of tupes)
type relation = [{}]

# Generic array
# TODO: an array of anything, not just nulls
type array = [null]

# Scalar
type scalar = int || float || bool || text || date || time || timestamp || null
type scalar_tuple = {scalar..}

# Aggregate functions
# These return either a scalar when used within `aggregate`, or a column when used anywhere else.
let min = column -> <scalar || array> null
let max = column -> <scalar || array> null
let sum = column -> <scalar || array> null
let avg = column -> <scalar || array> null
let stddev = column -> <scalar || array> null
let average = column -> <scalar || array> null
let count = non_null:s"*" -> <scalar || array> null
# TODO: Possibly make this into `count distinct:true` (or like `distinct:` as an
# abbreviation of that?)
let count_distinct = column -> <scalar || array> null

# Window functions
let lag = offset column -> <array> null
let lead = offset column -> <array> null
let first = offset column -> <array> null
let last = offset column -> <array> null
let rank = -> <array> null
let rank_dense = -> <array> null
let row_number = -> <array> null

# Other functions
let round = n_digits column -> <scalar> null
let as = `noresolve.type` column -> <scalar> null
let in = pattern value -> <bool> null

# Transform type definitions
let from = `default_db.source`<relation> -> <relation> null
let select = columns<scalar_tuple || scalar> tbl<relation> -> <relation> null
let filter = condition<bool> tbl<relation> -> <relation> null
let derive = columns<scalar_tuple || scalar> tbl<relation> -> <relation> null
let aggregate = columns<scalar_tuple || scalar> tbl<relation> -> <relation> null
let sort = by<scalar_tuple || scalar> tbl<relation> -> <relation> null
let take = expr<scalar> tbl<relation> -> <relation> null
let join = `default_db.with`<relation> filter<bool> `noresolve.side`:inner tbl<relation> -> <relation> null
let group = by pipeline tbl<relation> -> <relation> null
let window = rows:0..0 range:0..0 expanding:false rolling:0 pipeline tbl<relation> -> <relation> null

let noop = x -> x

let append = `default_db.bottom`<relation> top<relation> -> <relation> null
let intersect = `default_db.bottom`<relation> top<relation> -> <relation> (
    noop t = top
    join (noop b = bottom) (all (map _eq (zip t.* b.*)))
    select t.*
)
let remove = `default_db.bottom`<relation> top<relation> -> <relation> (
    noop t = top
    join side:left (noop b = bottom) (all (map _eq (zip t.* b.*)))
    filter (all (map _is_null b.*))
    select t.*
)
let loop = pipeline top<relation> -> <relation> null

# Array functions
let all = list -> <bool> null
let map = fn list -> null
let zip = a b -> null
let _eq = a -> null
let _is_null = a -> _param.a == null

# Misc
let from_text = input<text> `noresolve.format`:csv -> <relation> null

# String functions
let lower = column -> <text> null
let upper = column -> <text> null

# Source-reading functions, primarily for DuckDB
let read_parquet = source<text> -> <relation> s"SELECT * FROM read_parquet({source})"
let read_csv = source<text> -> <relation> s"SELECT * FROM read_csv_auto({source})"
