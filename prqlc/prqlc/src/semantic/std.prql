# The PRQL standard library defines the following functions and transforms.
# The definitions are whitespace insensitive, and have this form:
#
# ```
# let my_func = param1 param2 ...  -> <return_type> body_expr
# ```
#
# Where:
#   * `my_func` is the name of the function
#   * `param1` is the first parameter optionally followed by a type in "< ... >"
#   * `param2` etc. follow the same pattern as param1
#   * `<return_type>` is the type of result wrapped in "< ... >"
#   * `body_expr` defines the function body that creates the result.
#     It can be PRQL code or `internal ...` to indicate internal compiler code.

# Operators

let mul = left right -> <int> internal std.mul
let div_i = left right -> <int> internal std.div_i
let div_f = left right -> <int> internal std.div_f
let mod = left right -> <int> internal std.mod
let add = left right -> <int> internal std.add
let sub = left right -> <int> internal std.sub
let eq = left right -> <bool> internal std.eq
let ne = left right -> <bool> internal std.ne
let gt = left right -> <bool> internal std.gt
let lt = left right -> <bool> internal std.lt
let gte = left right -> <bool> internal std.gte
let lte = left right -> <bool> internal std.lte
let and = left<bool> right<bool> -> <bool> internal std.and
let or = left<bool> right<bool> -> <bool> internal std.or
let coalesce = left right -> internal std.coalesce
let regex_search = text pattern -> <bool> internal std.regex_search

let neg = expr<int> -> <int> internal std.neg
let not = expr<bool> -> <bool> internal std.not

# Types

## Type primitives
type int = int
type float = float
type bool = bool
type text = text
type date = date
type time = time
type timestamp = timestamp
type `func` = func

## Generic array

## Range
# type range <T> = {start = T, end = T}

## Transform
# type transform <I, O> = func [I] -> [O]

# Functions

## Relational transforms
let from = func <R>
  tbl <R>
  -> <R> tbl

@(coerce_tuple 0)
@(implicit_closure 0 this:1)
let select = func <I, A>
  assigns <A>
  tbl <[I]>
  -> <[A]> internal select

@(implicit_closure 0 this:1)
let filter = func <T>
  condition <bool>
  tbl <[T]>
  -> <[T]> internal filter

@(coerce_tuple 0)
@(implicit_closure 0 this:1)
let derive = func <I, A>
  assigns <A>
  tbl <[I]>
  -> <[{I, ..A}]> internal derive

@(coerce_tuple 0)
@(implicit_closure 0 this:1)
let aggregate = func <I, A>
  assigns <A>
  tbl <[I]>
  -> <[A]> internal aggregate

@(coerce_tuple 0)
@(implicit_closure 0 this:1)
let sort = func <I>
  by
  tbl <[I]>
  -> <[I]> internal sort

let take = func <I>
  expr
  tbl <[I]>
  -> <[I]> internal take

@(implicit_closure 1 this:2 that:0)
let join = func <A, B>
  with <[B]>
  condition <bool>
  `noresolve.side`:inner
  tbl <[A]>
  -> <[{A, B}]> internal join

@(coerce_tuple 0)
@(implicit_closure 0 this:2)
let group = func <I, B, PO>
  by<B>
  pipeline <func [I - B] -> [PO]>
  tbl <[I]>
  -> <[{B, ..PO}]> internal group

let window = func
  rows:0..-1
  range:0..-1
  expanding <bool>:false
  rolling <int>:0
  pipeline
  tbl
  -> internal window

let append = bottom top -> internal append
# let intersect = bottom top -> (
#   t = top
#   join (b = bottom) (std.tuple_every (std.tuple_map std._eq (std.tuple_zip t.* b.*)))
#   select t.*
# )
# let remove = bottom top -> (
#   t = top
#   join side:left (b = bottom) (std.tuple_every (std.tuple_map std._eq (std.tuple_zip t.* b.*)))
#   filter (std.tuple_every (std.tuple_map std._is_null b.*))
#   select t.*
# )
let loop = func
  pipeline
  top
  -> internal loop

## Aggregate functions
# These return either a scalar when used within `aggregate`, or a column when used anywhere else.

let min = column -> <int> internal std.min

let max = column -> <int> internal std.max

let sum = column -> <int> internal std.sum

let average = column -> <float> internal std.average

let stddev = column -> <float> internal std.stddev

let all = column -> <bool> internal std.all

let any = column -> <bool> internal std.any

let concat_array = column -> <text> internal std.concat_array

# Counts number of items in the column.
# Note that the count will include null values.
let count = colum -> <int> internal count

# Deprecated in favour of filterning input to the [std.count] function (not yet implemented).
@{deprecated}
let count_distinct = column -> internal std.count_distinct

## Window functions
let lag =   offset <int>    column -> internal std.lag
let lead =  offset <int>    column -> internal std.lead
let first      = column -> internal std.first
let last       = column -> internal std.last
let rank       = column -> internal std.rank
let rank_dense = column -> internal std.rank_dense
let row_number = column -> internal row_number

# Mathematical functions
module math {
  let abs = column -> <int> internal std.math.abs
  let floor = column -> <int> internal std.math.floor
  let ceil = column -> <int> internal std.math.ceil
  let pi <float> = internal std.math.pi
  let exp = column -> <int> internal std.math.exp
  let ln = column -> <int> internal std.math.ln
  let log10 = column -> <int> internal std.math.log10
  let log = base<int> column -> <int> internal std.math.log
  let sqrt = column -> <int> internal std.math.sqrt
  let degrees = column -> <int> internal std.math.degrees
  let radians = column -> <int> internal std.math.radians
  let cos = column -> <int> internal std.math.cos
  let acos = column -> <int> internal std.math.acos
  let sin = column -> <int> internal std.math.sin
  let asin = column -> <int> internal std.math.asin
  let tan = column -> <int> internal std.math.tan
  let atan = column -> <int> internal std.math.atan
  let pow = exponent<int> column -> <int> internal std.math.pow
  let round = n_digits column -> internal std.math.round
}

## Misc functions
let as = `noresolve.type` column -> internal std.as
let in = pattern value -> <bool> internal in

## Tuple functions
let tuple_every = func list -> <bool> internal tuple_every
let tuple_map = func fn <func> list -> internal tuple_map
let tuple_zip = func a b -> internal tuple_zip
let _eq = func a -> internal _eq
let _is_null = func a -> a == null

## Misc
let from_text = func <R: {}> input<text> `noresolve.format`:csv -> <[R]> internal from_text

## Text functions
module text {
  let lower = column -> <text> internal std.text.lower
  let upper = column -> <text> internal std.text.upper
  let ltrim = column -> <text> internal std.text.ltrim
  let rtrim = column -> <text> internal std.text.rtrim
  let trim = column -> <text> internal std.text.trim
  let length = column -> <int> internal std.text.length
  let extract = offset<int> length<int> column -> <text> internal std.text.extract
  let replace = pattern<text> replacement<text> column -> <text> internal std.text.replace
  let starts_with = prefix<text> column -> <bool> internal std.text.starts_with
  let contains = substr<text> column -> <bool> internal std.text.contains
  let ends_with = suffix<text> column -> <bool> internal std.text.ends_with
}

## Date functions
module date {
  let to_text = format<text> column -> <text> internal std.date.to_text
}

## File-reading functions, primarily for DuckDB
let read_parquet = func <R: {}> source<text> -> <[R]> internal std.read_parquet
# let read_csv = func <R: {}> source<text> -> <[R]> internal std.read_csv

## PRQL compiler functions
module `prql` {
  let version <text> = internal prql_version
}

# Deprecated, will be removed in 0.12.0
let prql_version <text> = internal prql_version
