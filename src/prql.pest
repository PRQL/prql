// TODO:
// - Some rules are silent because we don't strictly need them, but that may be
//   too rushed — maybe we do actually want to know about e.g. comments.
// - Need to resolve how to handle "inline pipelines"; there is a rule here but
//   it's not used or tested. It's partly a language question — do those need to
//   start with `from`? How do these work in the midst of an `aggregate` transform?

WHITESPACE = _{ " " }
// Need to exclude # in strings (and maybe confirm whether this the syntax we want)
COMMENT = _{ "#" ~ (!NEWLINE ~ ANY) * }

function = { "func" ~ idents ~ "=" ~ items }
table = { "table" ~ ident ~ "=" ~ "(" ~ NEWLINE* ~ pipeline ~ NEWLINE* ~ ")" }

query = _{ SOI ~ NEWLINE* ~ pipeline ~ NEWLINE* ~ EOI }

pipe = _{ NEWLINE | "|" }
pipeline = { transformation ~ (pipe ~ transformation)* }
// `ident` is the transformation name
transformation = { WHITESPACE* ~ ident ~ expr }
// TODO: resolve
inline_pipeline = !{ "(" ~ pipeline ~ ")" }

ident = @{ ( ASCII_ALPHA ~ (ASCII_ALPHANUMERIC | "." | "_" )* ) }
idents = { ident+ }

expr = _{ ( single_expr )+ }
// When taking only the next expression
single_expr = _{ ( parenthesized_expr | list | named_arg | assign | term | inline_pipeline ) }
// We could just put these all into `single_expr`, though possibly we want to retain a
// notion of a valid block (i.e. `+` is not a valid expression).
term = _{ ( ident | operator | number | quoted_string ) }
// A non-silent version of `expr`, so we can break up a list or parentheses. A
// more general version of this would be to make `expr` non-silent, but it would
// mean basically everything would be in an `expr`, which would be verbose to
// parse.
items = !{ expr }
// If possible, parse a single expr, otherwise parse a list of items, adding a
// layer. In cases like [a, b], we don't need `a` to be Items -> Ident -> a;
// only Ident -> a; but in [a b], we do need an Items parent to discriminate it
// from `[a, b]`.
// Note that it's a bit complicated with `&( NEWLINE? ~ ("," | "]"))` — we want
// to ensure there is a end to the expression, and we allow a NEWLINE to be between
// the current expression and the ending token. (Feel free to change and see the
// test diffs.)
single_expr_if_possible = _{ (( single_expr ~ &( NEWLINE? ~ ("," | "]") ) ) | items ) }
list = !{ "[" ~ NEWLINE? ~ single_expr_if_possible ~ ("," ~ NEWLINE? ~ single_expr_if_possible )* ~ ","? ~ NEWLINE? ~ "]" }
parenthesized_expr = _{ "(" ~ items ~ ")" }

// TODO: escapes
// https://pest.rs/book/examples/rust/literals.html
string = { (ASCII_ALPHANUMERIC | " " | "." | "_" | "-" | "\\"  )* }
quoted_string = _{ "\"" ~ string ~ "\"" }
number = @{ ( ASCII_DIGIT | "." )+ }
operator = @{ "==" | "!=" | "=" | ">" | "<" | ">=" | "<=" | "+" | "-" | "*" | "/" | "%" }

// Currently named_args and handled slightly differently to assignments:
// named_args have no whitespace and take one expression immediately after the
// `:`, while assignments take all of the expressions following the `:`. e.g.:
//
// derive cost: costA + costB
//
// vs.
//
// aggregate by:[title]
//
// ref https://github.com/max-sixty/prql/issues/53, this is not an ideal state,
// since small differences in whitespace have a large different in outcome.
//
// (The `assign` is more complicated because of
// https://github.com/pest-parser/pest/issues/502. An alternative would be to
// rely on precedence rather than whitespace by always having it before
// `named_arg` to ensure assignments parse as assignments rather than
// named_args.)
assign = ${ ident ~ WHITESPACE* ~ ":" ~ WHITESPACE+ ~ items }
named_arg = ${ ident ~ ":" ~ single_expr }
