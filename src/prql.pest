// TODO:
// - Some rules are silent because we don't strictly need them, but that may be
//   too rushed — maybe we do actually want to know about e.g. comments in the
//   parse tree (and potentially put them into SQL comments)
// - Need to resolve how to handle "inline pipelines"; there is a rule here but
//   it's not used or tested. It's partly a language question — do those need to
//   start with `from`? How do these work in the midst of an `aggregate`
//   transform?
// - Currently there's no concept of what expressions are allowed. e.g. `1 + 1`
//   is valid, but so is `1 1`. Or `foo bar` is not parsed at this stage as
//   `foo` being a function and `bar` its argument — it's just parsed into a
//   sequence of idents. We could instead parse these explicitly, and then
//   disallow `1 1`.

WHITESPACE = _{ " " }
// Need to exclude # in strings (and maybe confirm whether this the syntax we want)
COMMENT = _{ "#" ~ (!NEWLINE ~ ANY) * }

query = { SOI ~ NEWLINE* ~ (( function | table | pipeline ) ~ ( NEWLINE+ | &EOI ))* ~ EOI }

function = { "func" ~ idents ~ "=" ~ expr_silent }
table = { "table" ~ ident ~ "=" ~ "(" ~ NEWLINE* ~ pipeline ~ NEWLINE* ~ ")" }

pipe = _{ NEWLINE | "|" }
// TODO: should this allow for multiple line breaks?
pipeline = { transformation ~ (pipe ~ transformation)* }
// `ident` is the transformation name.
// Should this be `Terms` or `Expr`? With `Terms`, we can't have `filter x = 1`; only
// `filter (x = 1)`, so choosing `Expr`.
transformation = { WHITESPACE* ~ ident ~ expr_silent? }
// We don't model this in the same way as a pipeline, since the first term isn't
// a transformation. And it's somewhat related to our transformations being
// separate from our function calls (generally just `idents`) at the moment — we
// could unify them at some point.
inline_pipeline = { "(" ~ expr ~ (pipe ~ expr)+ ~ ")" }

ident = @{ ( ASCII_ALPHA ~ (ASCII_ALPHANUMERIC | "." | "_" )* ) }
idents = { ident+ }

// A central issue around the Terms vs Expr is that we want to be able to parse:
//   [foo bar + 1, 2]
// as:
// - foo bar + 1
//   - foo bar
//     - foo
//     - bar
//   - +
//   - 1
// - 2
// So this requires two non-silent rules:
// - A notion of list item that contains anything, including operators (but
//   not commas); e.g. `foo bar + 1`.
// - A notion of Expr that aggregates things between operators, e.g. foo bar.
// So we call the list item `Expr`, and the things between separators `terms`.
//
// We could have them be the same, but then we need logic in the parser to
// account for where the list item is in this parse tree
// - foo bar
//   - foo
//   - bar
// - +
// - 1
// - 2

// Adding the WHITESPACE is like making it a compound-atomic operator.
expr = { ( terms | operator | WHITESPACE )+ }
// For when we want to include separators, but don't need to break between them;
// e.g. in function definitions; where `func x = x + 1` can have `x + 1` as a
// single sequence of Expr. Alternative we could arguably discard this and
// unnest when creating the AST (which currently we do anyway).
expr_silent = _{ ( terms | operator | WHITESPACE )+ }
terms = !{ term+ }
// Should assign be here?
term = _{ ( parenthesized_expr | list | named_arg | assign | s_string | ident | number | string_literal | inline_pipeline ) }
list = !{ "[" ~ NEWLINE? ~ expr ~ ("," ~ NEWLINE? ~ expr )* ~ ","? ~ NEWLINE? ~ "]" }
parenthesized_expr = _{ "(" ~ expr ~ ")" }

// TODO: escapes
// https://pest.rs/book/examples/rust/literals.html

// We need to have a non-silent rule which contains the quotes, because of
// https://github.com/pest-parser/pest/issues/583, and then when converting to
// AST, we only keep the `string` and discard the `string_literal` given it
// contains the quotes.
//
// TODO: I'm still a bit unclear how preceeding and trailing spaces are working
// -- it seems that inner spaces are included without an atomic operator (or
// with `ANY`), but prceeding & trailing spaces require both `ANY` _and_ an
// atomic operator. We have some rudimentary tests for these.
string = { ( !( "\\" | "\"" ) ~ ANY )+ }
// TODO: allow single quotes.
string_literal = ${ "\"" ~ string ~ "\"" }
number = ${ ( ASCII_DIGIT | "." )+ }

// These separate idents from each other — i.e. `foo bar and baz` will parse into
// a) `foo bar`, `and`, `baz`, where `foo bar` is presumably a function call.
// TODO: review operators
operator = ${ "and" | "or" | "not" | "==" | "!=" | "=" | ">" | "<" | ">=" | "<=" | "+" | "-" | "*" | "/" | "%" }

s_string = ${ "s\"" ~ ( s_string_string | ( "{" ~ expr ~ "}" ))* ~ "\"" }
s_string_string = { ( !( "\\" | "\"" | "{" ) ~ ANY )+ }

// Currently named_args and handled slightly differently to assignments:
// named_args have no whitespace and take one expression immediately after the
// `:`, while assignments take all of the expressions following the `:`. e.g.:
//
// derive cost: costA + costB
//
// vs.
//
// aggregate by:[title]
//
// ref https://github.com/max-sixty/prql/issues/53, this is not an ideal state,
// since small differences in whitespace have a large different in outcome.
//
// (The `assign` is more complicated because of
// https://github.com/pest-parser/pest/issues/502. An alternative would be to
// rely on precedence rather than whitespace by always having it before
// `named_arg` to ensure assignments parse as assignments rather than
// named_args.)
assign = ${ ident ~ WHITESPACE* ~ ":" ~ WHITESPACE+ ~ expr }
named_arg = ${ ident ~ ":" ~ term }

// We no longer use this, but keeping here for reference, as it was a useful
// pattern for reducing nesting.
// // If possible, parse a single expr, otherwise parse a list of Expr, adding a
// // layer. In cases like [a, b], we don't need `a` to be Expr -> Ident -> a;
// // only Ident -> a; but in [a b], we do need an Expr parent to discriminate it
// // from `[a, b]`.
// // Note that it's a bit complicated with `&( NEWLINE? ~ ("," | "]"))` — we want
// // to ensure there is a end to the expression, and we allow a NEWLINE to be between
// // the current expression and the ending token. (Feel free to change and see the
// // test diffs.)
// // single_expr_if_possible = _{ (( item ~ &( NEWLINE? ~ ("," | "]") ) ) | Expr ) }
